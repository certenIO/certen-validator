// Copyright 2025 Certen Protocol
//
// Prometheus Metrics for Consensus Health Monitoring
// Per BFT Resiliency Task 5: Prometheus Metrics & Alerting

package metrics

import (
	"net/http"
	"sync"
	"time"

	"github.com/prometheus/client_golang/prometheus"
	"github.com/prometheus/client_golang/prometheus/promhttp"
)

var (
	// Consensus metrics
	consensusHeight = prometheus.NewGauge(prometheus.GaugeOpts{
		Namespace: "certen",
		Subsystem: "consensus",
		Name:      "height",
		Help:      "Current consensus block height",
	})

	consensusStallSeconds = prometheus.NewGauge(prometheus.GaugeOpts{
		Namespace: "certen",
		Subsystem: "consensus",
		Name:      "stall_seconds",
		Help:      "Seconds since last block (0 if not stalled)",
	})

	consensusLastBlockTime = prometheus.NewGauge(prometheus.GaugeOpts{
		Namespace: "certen",
		Subsystem: "consensus",
		Name:      "last_block_timestamp",
		Help:      "Unix timestamp of last committed block",
	})

	validatorPeers = prometheus.NewGauge(prometheus.GaugeOpts{
		Namespace: "certen",
		Subsystem: "validator",
		Name:      "peers",
		Help:      "Number of connected peers",
	})

	validatorIsStalled = prometheus.NewGauge(prometheus.GaugeOpts{
		Namespace: "certen",
		Subsystem: "validator",
		Name:      "is_stalled",
		Help:      "1 if consensus is stalled, 0 otherwise",
	})

	validatorConsecutiveStalls = prometheus.NewCounter(prometheus.CounterOpts{
		Namespace: "certen",
		Subsystem: "validator",
		Name:      "consecutive_stalls_total",
		Help:      "Total number of consecutive stall events",
	})

	// Proof metrics
	proofsGeneratedTotal = prometheus.NewCounterVec(prometheus.CounterOpts{
		Namespace: "certen",
		Subsystem: "proof",
		Name:      "generated_total",
		Help:      "Total proofs generated by type",
	}, []string{"type"}) // type: L1, L2, L3, G0, G1, G2

	proofGenerationDuration = prometheus.NewHistogramVec(prometheus.HistogramOpts{
		Namespace: "certen",
		Subsystem: "proof",
		Name:      "generation_duration_seconds",
		Help:      "Time to generate proofs",
		Buckets:   []float64{0.1, 0.5, 1, 2, 5, 10, 30, 60},
	}, []string{"type"})

	proofVerificationTotal = prometheus.NewCounterVec(prometheus.CounterOpts{
		Namespace: "certen",
		Subsystem: "proof",
		Name:      "verification_total",
		Help:      "Total proof verifications by result",
	}, []string{"type", "result"}) // result: success, failure

	// Attestation metrics
	attestationRequestsTotal = prometheus.NewCounter(prometheus.CounterOpts{
		Namespace: "certen",
		Subsystem: "attestation",
		Name:      "requests_total",
		Help:      "Total attestation requests sent",
	})

	attestationResponsesTotal = prometheus.NewCounterVec(prometheus.CounterOpts{
		Namespace: "certen",
		Subsystem: "attestation",
		Name:      "responses_total",
		Help:      "Total attestation responses by result",
	}, []string{"result"}) // result: success, failure, timeout

	attestationQuorumReached = prometheus.NewCounter(prometheus.CounterOpts{
		Namespace: "certen",
		Subsystem: "attestation",
		Name:      "quorum_reached_total",
		Help:      "Total times attestation quorum was reached",
	})

	// Anchor metrics
	anchorsCreatedTotal = prometheus.NewCounter(prometheus.CounterOpts{
		Namespace: "certen",
		Subsystem: "anchor",
		Name:      "created_total",
		Help:      "Total anchors created on Ethereum",
	})

	anchorCreationDuration = prometheus.NewHistogram(prometheus.HistogramOpts{
		Namespace: "certen",
		Subsystem: "anchor",
		Name:      "creation_duration_seconds",
		Help:      "Time to create anchor on Ethereum",
		Buckets:   []float64{1, 5, 10, 30, 60, 120, 300},
	})

	anchorGasUsed = prometheus.NewHistogram(prometheus.HistogramOpts{
		Namespace: "certen",
		Subsystem: "anchor",
		Name:      "gas_used",
		Help:      "Gas used for anchor transactions",
		Buckets:   []float64{100000, 200000, 500000, 1000000, 2000000},
	})

	// Intent metrics
	intentsDiscoveredTotal = prometheus.NewCounter(prometheus.CounterOpts{
		Namespace: "certen",
		Subsystem: "intent",
		Name:      "discovered_total",
		Help:      "Total intents discovered from Accumulate",
	})

	intentsProcessedTotal = prometheus.NewCounterVec(prometheus.CounterOpts{
		Namespace: "certen",
		Subsystem: "intent",
		Name:      "processed_total",
		Help:      "Total intents processed by result",
	}, []string{"result"}) // result: success, failure

	// BFT metrics
	bftBlocksCommittedTotal = prometheus.NewCounter(prometheus.CounterOpts{
		Namespace: "certen",
		Subsystem: "bft",
		Name:      "blocks_committed_total",
		Help:      "Total BFT blocks committed",
	})

	bftVotingPower = prometheus.NewGauge(prometheus.GaugeOpts{
		Namespace: "certen",
		Subsystem: "bft",
		Name:      "voting_power",
		Help:      "Current validator voting power",
	})

	// System metrics
	validatorUptime = prometheus.NewGauge(prometheus.GaugeOpts{
		Namespace: "certen",
		Subsystem: "system",
		Name:      "uptime_seconds",
		Help:      "Validator uptime in seconds",
	})

	validatorStatus = prometheus.NewGaugeVec(prometheus.GaugeOpts{
		Namespace: "certen",
		Subsystem: "system",
		Name:      "component_status",
		Help:      "Status of system components (1=healthy, 0=unhealthy)",
	}, []string{"component"}) // component: database, ethereum, accumulate, bft

	// Singleton registration
	registerOnce sync.Once
	startTime    time.Time
)

// RegisterMetrics registers all Prometheus metrics
func RegisterMetrics() {
	registerOnce.Do(func() {
		startTime = time.Now()

		// Consensus metrics
		prometheus.MustRegister(consensusHeight)
		prometheus.MustRegister(consensusStallSeconds)
		prometheus.MustRegister(consensusLastBlockTime)
		prometheus.MustRegister(validatorPeers)
		prometheus.MustRegister(validatorIsStalled)
		prometheus.MustRegister(validatorConsecutiveStalls)

		// Proof metrics
		prometheus.MustRegister(proofsGeneratedTotal)
		prometheus.MustRegister(proofGenerationDuration)
		prometheus.MustRegister(proofVerificationTotal)

		// Attestation metrics
		prometheus.MustRegister(attestationRequestsTotal)
		prometheus.MustRegister(attestationResponsesTotal)
		prometheus.MustRegister(attestationQuorumReached)

		// Anchor metrics
		prometheus.MustRegister(anchorsCreatedTotal)
		prometheus.MustRegister(anchorCreationDuration)
		prometheus.MustRegister(anchorGasUsed)

		// Intent metrics
		prometheus.MustRegister(intentsDiscoveredTotal)
		prometheus.MustRegister(intentsProcessedTotal)

		// BFT metrics
		prometheus.MustRegister(bftBlocksCommittedTotal)
		prometheus.MustRegister(bftVotingPower)

		// System metrics
		prometheus.MustRegister(validatorUptime)
		prometheus.MustRegister(validatorStatus)
	})
}

// MetricsHandler returns the Prometheus HTTP handler
func MetricsHandler() http.Handler {
	return promhttp.Handler()
}

// ============================================
// Consensus Metrics Functions
// ============================================

// SetConsensusHeight sets the current consensus height
func SetConsensusHeight(height int64) {
	consensusHeight.Set(float64(height))
}

// SetConsensusStallSeconds sets the stall duration
func SetConsensusStallSeconds(seconds float64) {
	consensusStallSeconds.Set(seconds)
}

// SetLastBlockTime sets the last block timestamp
func SetLastBlockTime(t time.Time) {
	consensusLastBlockTime.Set(float64(t.Unix()))
}

// SetValidatorPeers sets the connected peer count
func SetValidatorPeers(count int) {
	validatorPeers.Set(float64(count))
}

// SetValidatorStalled sets the stalled status
func SetValidatorStalled(stalled bool) {
	if stalled {
		validatorIsStalled.Set(1)
	} else {
		validatorIsStalled.Set(0)
	}
}

// IncrementConsecutiveStalls increments the stall counter
func IncrementConsecutiveStalls() {
	validatorConsecutiveStalls.Inc()
}

// ============================================
// Proof Metrics Functions
// ============================================

// RecordProofGenerated records a generated proof
func RecordProofGenerated(proofType string) {
	proofsGeneratedTotal.WithLabelValues(proofType).Inc()
}

// RecordProofGenerationDuration records proof generation time
func RecordProofGenerationDuration(proofType string, duration time.Duration) {
	proofGenerationDuration.WithLabelValues(proofType).Observe(duration.Seconds())
}

// RecordProofVerification records a proof verification result
func RecordProofVerification(proofType string, success bool) {
	result := "success"
	if !success {
		result = "failure"
	}
	proofVerificationTotal.WithLabelValues(proofType, result).Inc()
}

// ============================================
// Attestation Metrics Functions
// ============================================

// RecordAttestationRequest records an attestation request
func RecordAttestationRequest() {
	attestationRequestsTotal.Inc()
}

// RecordAttestationResponse records an attestation response
func RecordAttestationResponse(result string) {
	attestationResponsesTotal.WithLabelValues(result).Inc()
}

// RecordQuorumReached records a quorum achievement
func RecordQuorumReached() {
	attestationQuorumReached.Inc()
}

// ============================================
// Anchor Metrics Functions
// ============================================

// RecordAnchorCreated records an anchor creation
func RecordAnchorCreated() {
	anchorsCreatedTotal.Inc()
}

// RecordAnchorCreationDuration records anchor creation time
func RecordAnchorCreationDuration(duration time.Duration) {
	anchorCreationDuration.Observe(duration.Seconds())
}

// RecordAnchorGasUsed records gas used for anchor
func RecordAnchorGasUsed(gas uint64) {
	anchorGasUsed.Observe(float64(gas))
}

// ============================================
// Intent Metrics Functions
// ============================================

// RecordIntentDiscovered records an intent discovery
func RecordIntentDiscovered() {
	intentsDiscoveredTotal.Inc()
}

// RecordIntentProcessed records an intent processing result
func RecordIntentProcessed(success bool) {
	result := "success"
	if !success {
		result = "failure"
	}
	intentsProcessedTotal.WithLabelValues(result).Inc()
}

// ============================================
// BFT Metrics Functions
// ============================================

// RecordBFTBlockCommitted records a BFT block commit
func RecordBFTBlockCommitted() {
	bftBlocksCommittedTotal.Inc()
}

// SetBFTVotingPower sets the validator voting power
func SetBFTVotingPower(power int64) {
	bftVotingPower.Set(float64(power))
}

// ============================================
// System Metrics Functions
// ============================================

// UpdateUptime updates the uptime metric
func UpdateUptime() {
	validatorUptime.Set(time.Since(startTime).Seconds())
}

// SetComponentStatus sets a component's health status
func SetComponentStatus(component string, healthy bool) {
	status := 0.0
	if healthy {
		status = 1.0
	}
	validatorStatus.WithLabelValues(component).Set(status)
}

// ============================================
// Alert Thresholds (for documentation/reference)
// ============================================
//
// Recommended Prometheus alert rules:
//
// - alert: CertenConsensusStalled
//   expr: certen_consensus_stall_seconds > 120
//   for: 1m
//   labels:
//     severity: critical
//   annotations:
//     summary: "Certen consensus stalled"
//     description: "No new blocks for {{ $value }} seconds"
//
// - alert: CertenLowPeerCount
//   expr: certen_validator_peers < 2
//   for: 2m
//   labels:
//     severity: warning
//   annotations:
//     summary: "Low peer count"
//     description: "Only {{ $value }} peers connected"
//
// - alert: CertenConsensusHeightStagnant
//   expr: increase(certen_consensus_height[5m]) == 0
//   for: 5m
//   labels:
//     severity: critical
//   annotations:
//     summary: "Consensus height not increasing"
//     description: "Block height has not increased in 5 minutes"
//
// - alert: CertenComponentUnhealthy
//   expr: certen_system_component_status == 0
//   for: 1m
//   labels:
//     severity: warning
//   annotations:
//     summary: "Component unhealthy: {{ $labels.component }}"
//     description: "The {{ $labels.component }} component is reporting unhealthy"
