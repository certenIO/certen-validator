// Copyright 2025 Certen Protocol
//
// BLS ZK Setup Tool - Generates verification keys for Solidity deployment
//
// This tool performs the trusted setup for the BLS ZK-SNARK circuit:
//   1. Compiles the circuit
//   2. Generates proving and verification keys
//   3. Exports verification key in Solidity-compatible format
//
// Usage:
//   setup := NewBLSZKSetup()
//   setup.RunSetup()
//   setup.ExportForSolidity("./keys")

package bls_zkp

import (
	"encoding/hex"
	"encoding/json"
	"fmt"
	"math/big"
	"os"
	"path/filepath"
	"strings"
)

// BLSZKSetup handles ZK circuit setup and key generation
type BLSZKSetup struct {
	prover *BLSZKProver
}

// NewBLSZKSetup creates a new setup instance
func NewBLSZKSetup() *BLSZKSetup {
	return &BLSZKSetup{
		prover: NewBLSZKProver(),
	}
}

// RunSetup performs the trusted setup ceremony
func (s *BLSZKSetup) RunSetup() error {
	fmt.Println("=== BLS ZK-SNARK Setup ===")
	fmt.Println("")

	fmt.Println("1. Compiling circuit...")
	err := s.prover.Initialize()
	if err != nil {
		return fmt.Errorf("circuit compilation failed: %w", err)
	}
	fmt.Println("   Circuit compiled successfully")
	fmt.Println("")

	fmt.Println("2. Setup complete!")
	fmt.Println("   - Proving key generated")
	fmt.Println("   - Verification key generated")
	fmt.Println("")

	return nil
}

// ExportForSolidity exports verification key in Solidity-compatible format
func (s *BLSZKSetup) ExportForSolidity(outputDir string) error {
	if !s.prover.initialized {
		return fmt.Errorf("prover not initialized, run RunSetup first")
	}

	// Create output directory
	err := os.MkdirAll(outputDir, 0755)
	if err != nil {
		return fmt.Errorf("create output dir: %w", err)
	}

	// Export verification key
	vk, err := s.prover.ExportVerificationKey()
	if err != nil {
		return fmt.Errorf("export verification key: %w", err)
	}

	// Write JSON format
	jsonPath := filepath.Join(outputDir, "verification_key.json")
	jsonData, err := json.MarshalIndent(vk, "", "  ")
	if err != nil {
		return fmt.Errorf("marshal verification key: %w", err)
	}
	err = os.WriteFile(jsonPath, jsonData, 0644)
	if err != nil {
		return fmt.Errorf("write verification key JSON: %w", err)
	}
	fmt.Printf("Verification key JSON written to: %s\n", jsonPath)

	// Generate Solidity deployment code
	solidityCode := generateSoliditySetupCode(vk)
	solidityPath := filepath.Join(outputDir, "SetVerificationKey.sol")
	err = os.WriteFile(solidityPath, []byte(solidityCode), 0644)
	if err != nil {
		return fmt.Errorf("write Solidity code: %w", err)
	}
	fmt.Printf("Solidity setup code written to: %s\n", solidityPath)

	// Generate deployment script
	scriptCode := generateDeploymentScript(vk)
	scriptPath := filepath.Join(outputDir, "deploy_vk.js")
	err = os.WriteFile(scriptPath, []byte(scriptCode), 0644)
	if err != nil {
		return fmt.Errorf("write deployment script: %w", err)
	}
	fmt.Printf("Deployment script written to: %s\n", scriptPath)

	return nil
}

// SaveKeys saves the proving and verification keys to files
func (s *BLSZKSetup) SaveKeys(outputDir string) error {
	if !s.prover.initialized {
		return fmt.Errorf("prover not initialized, run RunSetup first")
	}

	err := os.MkdirAll(outputDir, 0755)
	if err != nil {
		return fmt.Errorf("create output dir: %w", err)
	}

	pkPath := filepath.Join(outputDir, "proving_key.bin")
	vkPath := filepath.Join(outputDir, "verification_key.bin")
	csPath := filepath.Join(outputDir, "constraint_system.bin")

	err = s.prover.SaveKeys(pkPath, vkPath, csPath)
	if err != nil {
		return fmt.Errorf("save keys: %w", err)
	}

	fmt.Printf("Keys saved to:\n")
	fmt.Printf("  - Proving key: %s\n", pkPath)
	fmt.Printf("  - Verification key: %s\n", vkPath)
	fmt.Printf("  - Constraint system: %s\n", csPath)

	return nil
}

// =============================================================================
// CODE GENERATION HELPERS
// =============================================================================

// generateSoliditySetupCode generates Solidity code to set the verification key
func generateSoliditySetupCode(vk *VerificationKeyExport) string {
	var sb strings.Builder

	sb.WriteString("// SPDX-License-Identifier: MIT\n")
	sb.WriteString("// Auto-generated verification key setup code\n")
	sb.WriteString("// Generated by CERTEN BLS ZK Setup Tool\n\n")
	sb.WriteString("pragma solidity ^0.8.20;\n\n")
	sb.WriteString("import \"./BLSZKVerifier.sol\";\n\n")
	sb.WriteString("/**\n")
	sb.WriteString(" * @title SetVerificationKey\n")
	sb.WriteString(" * @notice Helper contract to set the verification key on BLSZKVerifier\n")
	sb.WriteString(" */\n")
	sb.WriteString("contract SetVerificationKey {\n\n")

	// Function to set the verification key
	sb.WriteString("    /**\n")
	sb.WriteString("     * @notice Sets the verification key on the BLSZKVerifier contract\n")
	sb.WriteString("     * @param verifier Address of the BLSZKVerifier contract\n")
	sb.WriteString("     */\n")
	sb.WriteString("    function setKey(BLSZKVerifier verifier) external {\n")
	sb.WriteString("        // Alpha1 (G1 point)\n")
	sb.WriteString(fmt.Sprintf("        uint256[2] memory alpha1 = [uint256(%s), uint256(%s)];\n",
		bigIntToSolidityHex(vk.Alpha1[0]), bigIntToSolidityHex(vk.Alpha1[1])))
	sb.WriteString("\n")

	sb.WriteString("        // Beta2 (G2 point)\n")
	sb.WriteString(fmt.Sprintf("        uint256[2][2] memory beta2 = [[uint256(%s), uint256(%s)], [uint256(%s), uint256(%s)]];\n",
		bigIntToSolidityHex(vk.Beta2[0][0]), bigIntToSolidityHex(vk.Beta2[0][1]),
		bigIntToSolidityHex(vk.Beta2[1][0]), bigIntToSolidityHex(vk.Beta2[1][1])))
	sb.WriteString("\n")

	sb.WriteString("        // Gamma2 (G2 point)\n")
	sb.WriteString(fmt.Sprintf("        uint256[2][2] memory gamma2 = [[uint256(%s), uint256(%s)], [uint256(%s), uint256(%s)]];\n",
		bigIntToSolidityHex(vk.Gamma2[0][0]), bigIntToSolidityHex(vk.Gamma2[0][1]),
		bigIntToSolidityHex(vk.Gamma2[1][0]), bigIntToSolidityHex(vk.Gamma2[1][1])))
	sb.WriteString("\n")

	sb.WriteString("        // Delta2 (G2 point)\n")
	sb.WriteString(fmt.Sprintf("        uint256[2][2] memory delta2 = [[uint256(%s), uint256(%s)], [uint256(%s), uint256(%s)]];\n",
		bigIntToSolidityHex(vk.Delta2[0][0]), bigIntToSolidityHex(vk.Delta2[0][1]),
		bigIntToSolidityHex(vk.Delta2[1][0]), bigIntToSolidityHex(vk.Delta2[1][1])))
	sb.WriteString("\n")

	// IC points
	sb.WriteString(fmt.Sprintf("        // IC points (%d elements)\n", len(vk.IC)))
	sb.WriteString(fmt.Sprintf("        uint256[] memory ic_x = new uint256[](%d);\n", len(vk.IC)))
	sb.WriteString(fmt.Sprintf("        uint256[] memory ic_y = new uint256[](%d);\n", len(vk.IC)))
	sb.WriteString("\n")

	for i, ic := range vk.IC {
		sb.WriteString(fmt.Sprintf("        ic_x[%d] = %s;\n", i, bigIntToSolidityHex(ic[0])))
		sb.WriteString(fmt.Sprintf("        ic_y[%d] = %s;\n", i, bigIntToSolidityHex(ic[1])))
	}
	sb.WriteString("\n")

	sb.WriteString("        verifier.setVerificationKey(alpha1, beta2, gamma2, delta2, ic_x, ic_y);\n")
	sb.WriteString("    }\n")
	sb.WriteString("}\n")

	return sb.String()
}

// generateDeploymentScript generates JavaScript deployment script for Hardhat
func generateDeploymentScript(vk *VerificationKeyExport) string {
	var sb strings.Builder

	sb.WriteString("// Auto-generated deployment script\n")
	sb.WriteString("// Generated by CERTEN BLS ZK Setup Tool\n")
	sb.WriteString("//\n")
	sb.WriteString("// Usage: npx hardhat run deploy_vk.js --network sepolia\n\n")

	sb.WriteString("const { ethers } = require(\"hardhat\");\n\n")

	sb.WriteString("async function main() {\n")
	sb.WriteString("    const [deployer] = await ethers.getSigners();\n")
	sb.WriteString("    console.log(\"Setting verification key with account:\", deployer.address);\n\n")

	sb.WriteString("    // BLSZKVerifier contract address (update after deployment)\n")
	sb.WriteString("    const VERIFIER_ADDRESS = process.env.BLS_ZK_VERIFIER_ADDRESS || \"0x...\";\n\n")

	sb.WriteString("    const BLSZKVerifier = await ethers.getContractFactory(\"BLSZKVerifier\");\n")
	sb.WriteString("    const verifier = BLSZKVerifier.attach(VERIFIER_ADDRESS);\n\n")

	// Verification key values
	sb.WriteString("    // Verification key values\n")
	sb.WriteString(fmt.Sprintf("    const alpha1 = [\"%s\", \"%s\"];\n",
		bigIntToString(vk.Alpha1[0]), bigIntToString(vk.Alpha1[1])))

	sb.WriteString(fmt.Sprintf("    const beta2 = [[\"%s\", \"%s\"], [\"%s\", \"%s\"]];\n",
		bigIntToString(vk.Beta2[0][0]), bigIntToString(vk.Beta2[0][1]),
		bigIntToString(vk.Beta2[1][0]), bigIntToString(vk.Beta2[1][1])))

	sb.WriteString(fmt.Sprintf("    const gamma2 = [[\"%s\", \"%s\"], [\"%s\", \"%s\"]];\n",
		bigIntToString(vk.Gamma2[0][0]), bigIntToString(vk.Gamma2[0][1]),
		bigIntToString(vk.Gamma2[1][0]), bigIntToString(vk.Gamma2[1][1])))

	sb.WriteString(fmt.Sprintf("    const delta2 = [[\"%s\", \"%s\"], [\"%s\", \"%s\"]];\n",
		bigIntToString(vk.Delta2[0][0]), bigIntToString(vk.Delta2[0][1]),
		bigIntToString(vk.Delta2[1][0]), bigIntToString(vk.Delta2[1][1])))

	sb.WriteString("\n    const ic_x = [\n")
	for i, ic := range vk.IC {
		comma := ","
		if i == len(vk.IC)-1 {
			comma = ""
		}
		sb.WriteString(fmt.Sprintf("        \"%s\"%s\n", bigIntToString(ic[0]), comma))
	}
	sb.WriteString("    ];\n")

	sb.WriteString("\n    const ic_y = [\n")
	for i, ic := range vk.IC {
		comma := ","
		if i == len(vk.IC)-1 {
			comma = ""
		}
		sb.WriteString(fmt.Sprintf("        \"%s\"%s\n", bigIntToString(ic[1]), comma))
	}
	sb.WriteString("    ];\n\n")

	sb.WriteString("    console.log(\"Setting verification key...\");\n")
	sb.WriteString("    const tx = await verifier.setVerificationKey(alpha1, beta2, gamma2, delta2, ic_x, ic_y);\n")
	sb.WriteString("    await tx.wait();\n")
	sb.WriteString("    console.log(\"Verification key set successfully!\");\n")
	sb.WriteString("    console.log(\"Transaction hash:\", tx.hash);\n")
	sb.WriteString("}\n\n")

	sb.WriteString("main()\n")
	sb.WriteString("    .then(() => process.exit(0))\n")
	sb.WriteString("    .catch((error) => {\n")
	sb.WriteString("        console.error(error);\n")
	sb.WriteString("        process.exit(1);\n")
	sb.WriteString("    });\n")

	return sb.String()
}

// bigIntToSolidityHex converts a big.Int to Solidity hex literal
func bigIntToSolidityHex(n *big.Int) string {
	if n == nil || n.Sign() == 0 {
		return "0x0"
	}
	return "0x" + hex.EncodeToString(n.Bytes())
}

// bigIntToString converts a big.Int to decimal string
func bigIntToString(n *big.Int) string {
	if n == nil {
		return "0"
	}
	return n.String()
}

// =============================================================================
// COMMAND LINE INTERFACE
// =============================================================================

// RunSetupCLI runs the setup as a command-line tool
func RunSetupCLI() error {
	fmt.Println("╔═══════════════════════════════════════════════════╗")
	fmt.Println("║   CERTEN BLS ZK-SNARK Setup Tool                  ║")
	fmt.Println("║   Production-grade BLS signature verification     ║")
	fmt.Println("╚═══════════════════════════════════════════════════╝")
	fmt.Println("")

	setup := NewBLSZKSetup()

	// Run setup
	err := setup.RunSetup()
	if err != nil {
		return fmt.Errorf("setup failed: %w", err)
	}

	// Export to default directory
	outputDir := "./bls_zk_keys"
	fmt.Printf("\n3. Exporting keys to %s...\n", outputDir)

	err = setup.SaveKeys(outputDir)
	if err != nil {
		return fmt.Errorf("save keys failed: %w", err)
	}

	err = setup.ExportForSolidity(outputDir)
	if err != nil {
		return fmt.Errorf("export for Solidity failed: %w", err)
	}

	// Also print VK in format for update-bls-vk.js script
	vk, err := setup.prover.ExportVerificationKey()
	if err != nil {
		return fmt.Errorf("export verification key: %w", err)
	}

	fmt.Println("\n=== COPY THESE VALUES TO update-bls-vk.js ===")
	fmt.Println("// Copy the following into contracts/ethereum/scripts/update-bls-vk.js")
	fmt.Println("")
	fmt.Println("    const alpha1 = [")
	fmt.Printf("        \"%s\",\n", vk.Alpha1[0].String())
	fmt.Printf("        \"%s\"\n", vk.Alpha1[1].String())
	fmt.Println("    ];")
	fmt.Println("")
	fmt.Println("    const beta2 = [")
	fmt.Printf("        [\"%s\", \"%s\"],\n", vk.Beta2[0][0].String(), vk.Beta2[0][1].String())
	fmt.Printf("        [\"%s\", \"%s\"]\n", vk.Beta2[1][0].String(), vk.Beta2[1][1].String())
	fmt.Println("    ];")
	fmt.Println("")
	fmt.Println("    const gamma2 = [")
	fmt.Printf("        [\"%s\", \"%s\"],\n", vk.Gamma2[0][0].String(), vk.Gamma2[0][1].String())
	fmt.Printf("        [\"%s\", \"%s\"]\n", vk.Gamma2[1][0].String(), vk.Gamma2[1][1].String())
	fmt.Println("    ];")
	fmt.Println("")
	fmt.Println("    const delta2 = [")
	fmt.Printf("        [\"%s\", \"%s\"],\n", vk.Delta2[0][0].String(), vk.Delta2[0][1].String())
	fmt.Printf("        [\"%s\", \"%s\"]\n", vk.Delta2[1][0].String(), vk.Delta2[1][1].String())
	fmt.Println("    ];")
	fmt.Println("")
	fmt.Printf("    // %d IC points = %d public inputs + 1\n", len(vk.IC), len(vk.IC)-1)
	fmt.Println("    const ic_x = [")
	for i, ic := range vk.IC {
		comma := ","
		if i == len(vk.IC)-1 {
			comma = ""
		}
		fmt.Printf("        \"%s\"%s\n", ic[0].String(), comma)
	}
	fmt.Println("    ];")
	fmt.Println("")
	fmt.Println("    const ic_y = [")
	for i, ic := range vk.IC {
		comma := ","
		if i == len(vk.IC)-1 {
			comma = ""
		}
		fmt.Printf("        \"%s\"%s\n", ic[1].String(), comma)
	}
	fmt.Println("    ];")
	fmt.Println("")
	fmt.Println("=== END OF VK VALUES ===")

	fmt.Println("\n=== Setup Complete ===")
	fmt.Println("")
	fmt.Println("Key files saved to: ./bls_zk_keys/")
	fmt.Println("  - proving_key.bin    (used by validators)")
	fmt.Println("  - verification_key.bin (used by validators)")
	fmt.Println("  - constraint_system.bin (used by validators)")
	fmt.Println("  - verification_key.json (for reference)")
	fmt.Println("  - deploy_vk.js (Hardhat deployment script)")
	fmt.Println("")
	fmt.Println("CRITICAL: Follow these steps to deploy:")
	fmt.Println("  1. Copy the VK values above into contracts/ethereum/scripts/update-bls-vk.js")
	fmt.Println("  2. Deploy VK: cd contracts/ethereum && npx hardhat run scripts/update-bls-vk.js --network sepolia")
	fmt.Println("  3. Rebuild validators to include the new keys")
	fmt.Println("  4. Restart validators - they will load keys from ./bls_zk_keys/")
	fmt.Println("")
	fmt.Println("NOTE: The proving key and verification key MUST match.")
	fmt.Println("      Validators use proving_key.bin, the contract uses the VK you deployed.")
	fmt.Println("")

	return nil
}
